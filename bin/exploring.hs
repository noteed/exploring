{-# LANGUAGE RecordWildCards #-}
module Main where

import Codec.Picture (generateImage, writePng, PixelRGB8(PixelRGB8))
import Data.Binary
import Data.Binary.Get
import Data.Bits
import Data.ByteString (ByteString)
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import Data.List (intersperse)
import System.Environment (getArgs)
import System.IO (hClose, hSeek, openFile, IOMode(ReadMode), SeekMode(AbsoluteSeek))
import Text.Printf (printf)


--------------------------------------------------------------------------------
main :: IO ()
main = do
  args <- getArgs
  case args of
    ["sql-memlist"] -> do
      -- Generate an SQL representation of MEMLIST.BIN.
      entries <- readMemEntries "another-world/MEMLIST.BIN"
      putStrLn "-- Generated by bin/exploring sql-memlist."
      putStrLn "INSERT INTO memlist (\
        \id, state, type, packed_size, size, rank_num, bank_id, bank_offset) VALUES"
      mapM_ putStr (intersperse ",\n" (map toSQLTuple (zip [0..] entries)))
      putStrLn ";"

    ["read-bank", bankId, bankOffset, packedSize] -> do
      -- For instance to read the first pallete, which has also the smallest
      -- packed size:
      -- read-bank 1 95176 836
      s <- readBank (read bankId) (read bankOffset) (read packedSize)
      B.putStr s

    ["write-palette", n] -> do
      -- Write the ith palette from unpacked.bin to a .png file.
      let i = read n
      colors <- readColors "resources/unpacked-020.bin"
      -- Skip i palettes, and each color will cover 20 pixels.
      let f x y = (drop (i * 16) colors) !! (x `div` 20)
          img = generateImage f 320 240
      writePng (printf "images/palette-%02d.png" i) img

    ["write-bytecode", r] -> do
      -- Write the bytecode from resource n to stdout.
      let i = read r :: Int
      bytecode <- readBytecode (printf "resources/unpacked-%03d.bin" i)
      mapM_ print bytecode

    _ -> do
      -- More-or-less confirm we can read MEMLIST.BIN.
      putStrLn "Exploring Another World..."
      putStrLn "Reading entries from MEMLIST.BIN..."
      entries <- readMemEntries "another-world/MEMLIST.BIN"
      putStrLn ("Read " ++ show (length entries) ++ " entries.")
      putStrLn ("All but the last entry have a NotNeeded state: " ++
        show (all ((== MemEntryNotNeeded) . meState) (init entries)))
      putStrLn ("The last entry has a LastEntry state: " ++
        show (((== MemEntryLastEntry) . meState . last) entries))

toSQLTuple (i, MemEntry{..}) = concat
  [ "  ("
  , show i ++ ", \""
  , drop 8 (show meState) ++ "\", \""
  , drop 12 (show meType) ++ "\", "
  , show mePackedSize ++ ", "
  , show meSize ++ ", "
  , show meRankNum ++ ", "
  , show meBankId ++ ", "
  , show meBankOffset ++ ")"
  ]


--------------------------------------------------------------------------------
readBank :: Int -> Int -> Int -> IO B.ByteString
readBank bankId bankOffset packedSize = do
  let filename = "another-world/BANK" ++ printf "%02x" bankId
  handle <- openFile filename ReadMode
  hSeek handle AbsoluteSeek (fromIntegral bankOffset)
  s <- B.hGet handle packedSize
  hClose handle
  if B.length s < packedSize
    then error "Can't read bank."
    else return s


--------------------------------------------------------------------------------
-- Data deserialization.
-- Note that data are in big-endian format (similar to Atari and Amiga CPUs).

-- This struct is described at, and populated at:
-- https://github.com/fabiensanglard/Another-World-Bytecode-Interpreter/blob/master/src/resource.h#L34-L48
-- -- https://github.com/fabiensanglard/Another-World-Bytecode-Interpreter/blob/master/src/resource.cpp#L85-L96
data MemEntry = MemEntry
  { meState      :: MemEntryState
  , meType       :: ResourceType
  , meBufPtr     :: !Word8  -- ^ Initialized to zero in the above repository.
  , meUnused0    :: !Word16 -- ^ This one is skipped in the above repository.
  , meUnused1    :: !Word16
  , meRankNum    :: !Word8  -- ^ All zero, except the last one which is 255.
  , meBankId     :: !Word8  -- ^ Between 1 and 13 incl. except last one (255).
  , meBankOffset :: !Word32
  , meUnused2    :: !Word16
  , mePackedSize :: !Word16
  , meUnused3    :: !Word16
  , meSize       :: !Word16
  }

data MemEntryState =
    MemEntryNotNeeded -- ^ 0
  | MemEntryLoaded    -- ^ 1
  | MemEntryLoadMe    -- ^ 2
  | MemEntryLastEntry -- ^ 255
  deriving (Eq, Show)

data ResourceType =
    ResourceTypeSound     -- ^ 0
  | ResourceTypeMusic     -- ^ 1
  | ResourceTypePolyAnim  -- ^ 2
  | ResourceTypePalette   -- ^ 3
  | ResourceTypeBytecode  -- ^ 4
  | ResourceTypeCinematic -- ^ 5
  | ResourceTypeUnknown   -- ^ 6
  | ResourceTypeLastEntry -- ^ 255
  deriving (Eq, Show)

-- | Virtual machine operations (opcodes).
data Op =
    -- 0x00
    OpMovConst Word8 Word16
  | OpMov Word8 Word8
  | OpAdd Word8 Word8
  | OpAddConst Word8 Word16
    -- 0x04
  | OpCall Word16
  | OpRet
  | OpYieldThread
  | OpJmp Word16
    -- 0x08
  | OpSpawnThread Word8 Word16
  | OpJnz Word8 Word16
  | OpCondJmp OpCondJmp
  | OpSetPalette Word8
    -- 0x0C
  | OpResetThread Word8 Word8 Word8
  | OpSelectVideoPage Word8
  | OpFillVideoPage Word8 Word8
  | OpCopyVideoPage Word8 Word8
    -- 0x10
  | OpBlitFramebuffer Word8
  | OpKillThread
  | OpDrawString Word16 Word8 Word8 Word8
  | OpSub Word8 Word8
    -- 0x14
  | OpAnd Word8 Word16
  | OpOr Word8 Word16
  | OpShl Word8 Word16
  | OpShr Word8 Word16
    -- 0x18
  | OpPlaySound Word16 Word8 Word8 Word8
  | OpUpdateResources Word16
  | OpPlayMusic Word16 Word16 Word8
    -- 0x80, or 1000_0000, is set
  | OpDrawPolygon8 Word8 Word8 Word8
    -- 0x40, or 0100_0000, is set
  | OpDrawPolygon16 Word16 Word8 Word8 Word8
  deriving Show

data OpComp = Jz | Jnz | Jg | Jge | Jl | Jle
  deriving Show

data OpCondJmp =
    OpCondJmpVar OpComp Word8 Word8 Word16
  | OpCondJmpWord16 OpComp Word8 Word16 Word16
  | OpCondJmpWor8 OpComp Word8 Word8 Word16
  deriving Show


--------------------------------------------------------------------------------
-- MEMLIST.BIN stuff.


readMemEntries :: String -> IO [MemEntry]
readMemEntries fn = do
  input <- BL.readFile fn
  return (runGet getMemEntries input)

getMemEntries :: Get [MemEntry]
getMemEntries = do
  empty <- isEmpty
  if empty
    then return []
    else do
      e <- getMemEntry
      es <- getMemEntries
      return (e : es)

getMemEntry :: Get MemEntry
getMemEntry = do
  meState <- getMemEntryState
  meType <- getResourceType
  let meBufPtr = 0
  meUnused0 <- getWord16be
  meUnused1 <- getWord16be
  meRankNum <- getWord8
  meBankId <- getWord8
  meBankOffset <- getWord32be
  meUnused2 <- getWord16be
  mePackedSize <- getWord16be
  meUnused3 <- getWord16be
  meSize <- getWord16be
  return $! MemEntry {..}

getMemEntryState :: Get MemEntryState
getMemEntryState = do
  t <- getWord8
  case t of
    0 -> return MemEntryNotNeeded
    1 -> return MemEntryLoaded
    2 -> return MemEntryLoadMe
    255 -> return MemEntryLastEntry
    _ -> error ("getMemEntryState: unexpected word8.")

getResourceType :: Get ResourceType
getResourceType = do
  t <- getWord8
  case t of
    0 -> return ResourceTypeSound
    1 -> return ResourceTypeMusic
    2 -> return ResourceTypePolyAnim
    3 -> return ResourceTypePalette
    4 -> return ResourceTypeBytecode
    5 -> return ResourceTypeCinematic
    6 -> return ResourceTypeUnknown
    255 -> return ResourceTypeLastEntry


--------------------------------------------------------------------------------
-- Palette stuff.

readColors :: String -> IO [PixelRGB8]
readColors fn = do
  input <- BL.readFile fn
  return (runGet getColors input)

getColors :: Get [PixelRGB8]
getColors = do
  empty <- isEmpty
  if empty
    then return []
    else do
      c <- getColor
      cs <- getColors
      return (c : cs)

-- The bit manipulation to convert from 2-bytes 565 representation to
-- RGB8 is from Fabien's `sysImplementation.cpp`.
getColor :: Get PixelRGB8
getColor = do
  byte1 <- getWord8
  byte2 <- getWord8
  let i = byte1 .&. 0x0F
      j = byte2 .&. 0xF0
      k = byte2 .&. 0x0F
      r = ((shiftL i 2) .|. (shiftR i 2)) `shiftL` 2
      g = ((shiftR j 2) .|. (shiftR j 6)) `shiftL` 2
      b = ((shiftR k 2) .|. (shiftL k 2)) `shiftL` 2
  return (PixelRGB8 r g b)


--------------------------------------------------------------------------------
-- Bytecode stuff.

readBytecode :: String -> IO [Op]
readBytecode fn = do
  input <- BL.readFile fn
  return (runGet getBytecode input)

getBytecode :: Get [Op]
getBytecode = do
  empty <- isEmpty
  if empty
    then return []
    else do
      o <- getOp
      os <- getBytecode
      return (o : os)

getOp :: Get Op
getOp = do
  b <- getWord8
  case b of
    0x00 -> do
      var <- getWord8
      value <- getWord16be
      return (OpMovConst var value)
    0x01 -> do
      var0 <- getWord8
      var1 <- getWord8
      return (OpMov var0 var1)
    0x02 -> do
      var0 <- getWord8
      var1 <- getWord8
      return (OpAdd var0 var1)
    0x03 -> do
      var <- getWord8
      value <- getWord16be
      return (OpAddConst var value)
    0x04 -> do
      addr <- getWord16be
      return (OpCall addr)
    0x05 -> return OpRet
    0x06 -> return OpYieldThread
    0x07 -> do
      offset <- getWord16be
      return (OpJmp offset)
    0x08 -> do
      thread <- getWord8
      offset <- getWord16be
      return (OpSpawnThread thread offset)
    0x09 -> do
      var <- getWord8
      addr <- getWord16be
      return (OpJnz var addr)
    0x0A -> do
      opcode <- getWord8
      var <- getWord8
      let comp = case opcode .&. 7 of
                   0 -> Jz
                   1 -> Jnz
                   2 -> Jg
                   3 -> Jge
                   4 -> Jl
                   5 -> Jle
                   _ -> error "Invalid OpCondJmp comparison."
      case opcode of
        _ | (opcode .&. 0x80) /= 0 -> do
          var1 <- getWord8
          addr <- getWord16be
          return (OpCondJmp $ OpCondJmpVar comp var var1 addr)
        _ | (opcode .&. 0x40) /= 0 -> do
          value <- getWord16be
          addr <- getWord16be
          return (OpCondJmp $ OpCondJmpWord16 comp var value addr)
        _ -> do
          value <- getWord8
          addr <- getWord16be
          return (OpCondJmp $ OpCondJmpWor8 comp var value addr)
    0x0B -> do
      palette <- getWord8
      _ <- getWord8 -- Ignored unles this is 3DO.
      return (OpSetPalette palette)
    0x0C -> do
      thread <- getWord8
      a <- getWord8
      b <- getWord8
      return (OpResetThread thread a b)
    0x0D -> do
      framebuffer <- getWord8
      return (OpSelectVideoPage framebuffer)
    0x0E -> do
      page <- getWord8
      color <- getWord8
      return (OpFillVideoPage page color)
    0x0F -> do
      pageSrc <- getWord8
      pageDst <- getWord8
      return (OpCopyVideoPage pageSrc pageDst )
    0x10 -> do
      page <- getWord8
      return (OpBlitFramebuffer page)
    0x11 -> return OpKillThread
    0x12 -> do
      str <- getWord16be
      x <- getWord8
      y <- getWord8
      color <- getWord8
      return (OpDrawString str x y color)
    0x13 -> do
      var0 <- getWord8
      var1 <- getWord8
      return (OpSub var0 var1)
    0x14 -> do
      var <- getWord8
      value <- getWord16be
      return (OpAnd var value)
    0x15 -> do
      var <- getWord8
      value <- getWord16be
      return (OpOr var value)
    0x16 -> do
      var <- getWord8
      value <- getWord16be
      return (OpShl var value)
    0x17 -> do
      var <- getWord8
      value <- getWord16be
      return (OpShr var value)
    0x18 -> do
      resource <- getWord16be
      freq <- getWord8
      vol <- getWord8
      channel <- getWord8
      return (OpPlaySound resource freq vol channel)
    0x19 -> do
      resource <- getWord16be
      return (OpUpdateResources resource)
    0x1A -> do
      num <- getWord16be
      delay <- getWord16be
      pos <- getWord8
      return (OpPlayMusic num delay pos)
    -- TODO Some bit manipulation has to be done below. It is possible to
    -- combine the Word8 and Word16 together.
    -- TODO The correct polygon resource should be set: normal, or cinematic.
    -- The offset is an offset into that resource.
    _ | (b .&. 0x80) /= 0 -> do
      offset <- getWord8
      x <- getWord8
      y <- getWord8
      return (OpDrawPolygon8 offset x y) -- zoom is 64
    _ | (b .&. 0x40) /= 0 -> do
      offset <- getWord16be
      x <- getWord8
      _ <- if ((b .&. 0x20) == 0 && (b .&. 0x10) == 0)
           then getWord8 -- TODO
           else return 0
      y <- getWord8
      _ <- if ((b .&. 0x08) == 0 && (b .&. 0x04) == 0)
           then getWord8 -- TODO
           else return 0
      zoom <- if ( ((b .&. 0x02) == 0 && (b .&. 0x01) /= 0)
                || ((b .&. 0x02) /= 0 && (b .&. 0x01) == 0))
              then getWord8 -- TODO
              else return 0
      return (OpDrawPolygon16 offset x y zoom)
    _ -> do
      error (printf "Unexpected opcode 0x%02x" b)
