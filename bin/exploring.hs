{-# LANGUAGE RecordWildCards #-}
module Main where

import Data.Binary
import Data.Binary.Get
import Data.ByteString (ByteString)
import qualified Data.ByteString.Lazy as BL
import Data.List (intersperse)
import System.Environment (getArgs)


--------------------------------------------------------------------------------
main :: IO ()
main = do
  args <- getArgs
  case args of
    ["sql-memlist"] -> do
      -- Generate an SQL representqtion of MEMLIST.BIN.
      entries <- readMemEntries "another-world/MEMLIST.BIN"
      putStrLn "-- Generated by bin/exploring sql-memlist."
      putStrLn "INSERT INTO memlist (\
        \state, type, packed_size, size, rank_num, bank_id, bank_offset) VALUES"
      mapM_ putStr (intersperse ",\n" (map toSQLTuple entries))
      putStrLn ";"

    _ -> do
      -- More-or-less confirm we can read MEMLIST.BIN.
      putStrLn "Exploring Another World..."
      putStrLn "Reading entries from MEMLIST.BIN..."
      entries <- readMemEntries "another-world/MEMLIST.BIN"
      putStrLn ("Read " ++ show (length entries) ++ " entries.")
      putStrLn ("All but the last entry have a NotNeeded state: " ++
        show (all ((== MemEntryNotNeeded) . meState) (init entries)))
      putStrLn ("The last entry has a LastEntry state: " ++
        show (((== MemEntryLastEntry) . meState . last) entries))

toSQLTuple MemEntry{..} = concat
  [ "  (\""
  , drop 8 (show meState) ++ "\", \""
  , drop 12 (show meType) ++ "\", "
  , show mePackedSize ++ ", "
  , show meSize ++ ", "
  , show meRankNum ++ ", "
  , show meBankId ++ ", "
  , show meBankOffset ++ ")"
  ]


--------------------------------------------------------------------------------
-- Data deserialization.
-- Note that data are in big-endian format (similar to Atari and Amiga CPUs).

-- This struct is described at, and populated at:
-- https://github.com/fabiensanglard/Another-World-Bytecode-Interpreter/blob/master/src/resource.h#L34-L48
-- -- https://github.com/fabiensanglard/Another-World-Bytecode-Interpreter/blob/master/src/resource.cpp#L85-L96
data MemEntry = MemEntry
  { meState      :: MemEntryState
  , meType       :: ResourceType
  , meBufPtr     :: !Word8  -- ^ Initialized to zero in the above repository.
  , meUnused0    :: !Word16 -- ^ This one is skipped in the above repository.
  , meUnused1    :: !Word16
  , meRankNum    :: !Word8  -- ^ All zero, except the last one which is 255.
  , meBankId     :: !Word8  -- ^ Between 1 and 13 incl. except last one (255).
  , meBankOffset :: !Word32
  , meUnused2    :: !Word16
  , mePackedSize :: !Word16
  , meUnused3    :: !Word16
  , meSize       :: !Word16
  }

data MemEntryState =
    MemEntryNotNeeded -- ^ 0
  | MemEntryLoaded    -- ^ 1
  | MemEntryLoadMe    -- ^ 2
  | MemEntryLastEntry -- ^ 255
  deriving (Eq, Show)

data ResourceType =
    ResourceTypeSound     -- ^ 0
  | ResourceTypeMusic     -- ^ 1
  | ResourceTypePolyAnim  -- ^ 2
  | ResourceTypePalette   -- ^ 3
  | ResourceTypeByteCode  -- ^ 4
  | ResourceTypeCinematic -- ^ 5
  | ResourceTypeUnknown   -- ^ 6
  | ResourceTypeLastEntry -- ^ 255
  deriving (Eq, Show)


--------------------------------------------------------------------------------
readMemEntries :: String -> IO [MemEntry]
readMemEntries fn = do
  input <- BL.readFile fn
  return (runGet getMemEntries input)

getMemEntries :: Get [MemEntry]
getMemEntries = do
  empty <- isEmpty
  if empty
    then return []
    else do
      e <- getMemEntry
      es <- getMemEntries
      return (e : es)

getMemEntry :: Get MemEntry
getMemEntry = do
  meState <- getMemEntryState
  meType <- getResourceType
  let meBufPtr = 0
  meUnused0 <- getWord16be
  meUnused1 <- getWord16be
  meRankNum <- getWord8
  meBankId <- getWord8
  meBankOffset <- getWord32be
  meUnused2 <- getWord16be
  mePackedSize <- getWord16be
  meUnused3 <- getWord16be
  meSize <- getWord16be
  return $! MemEntry {..}

getMemEntryState :: Get MemEntryState
getMemEntryState = do
  t <- getWord8
  case t of
    0 -> return MemEntryNotNeeded
    1 -> return MemEntryLoaded
    2 -> return MemEntryLoadMe
    255 -> return MemEntryLastEntry
    _ -> error ("getMemEntryState: unexpected word8.")

getResourceType :: Get ResourceType
getResourceType = do
  t <- getWord8
  case t of
    0 -> return ResourceTypeSound
    1 -> return ResourceTypeMusic
    2 -> return ResourceTypePolyAnim
    3 -> return ResourceTypePalette
    4 -> return ResourceTypeByteCode
    5 -> return ResourceTypeCinematic
    6 -> return ResourceTypeUnknown
    255 -> return ResourceTypeLastEntry
